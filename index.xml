<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>只要逆流而上</title>
    <link>https://Cdreamfly.github.io/</link>
    <description>Recent content on 只要逆流而上</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Jan 2020 16:01:23 +0800</lastBuildDate>
    
        <atom:link href="https://Cdreamfly.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://Cdreamfly.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/about/</guid>
      
        <description>&lt;p&gt;三流的大学，三流的学生。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>1.两数之和</title>
      <link>https://Cdreamfly.github.io/post/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      
        <description>

&lt;h1 id=&#34;1-两数之和&#34;&gt;1. 两数之和&lt;/h1&gt;

&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;和一个目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回他们的数组下标。&lt;/p&gt;

&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;题解:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        vector&amp;lt;int&amp;gt;v(2);
        for(int i = 0;i&amp;lt;nums.size();i++)
        {
            for(int j = i+1;j&amp;lt;nums.size();j++)
            {
                if(nums[i]+nums[j] == target)
                {
                    v[0] = i;
                    v[1] = j;
                    return v;
                }
            }
        }
        return v;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后学会更好的解法在更新。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>13.罗马数字转整数</title>
      <link>https://Cdreamfly.github.io/post/13.-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/13.-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做  &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 可以放在 &lt;code&gt;V&lt;/code&gt; (5) 和 &lt;code&gt;X&lt;/code&gt; (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; 可以放在 &lt;code&gt;L&lt;/code&gt; (50) 和 &lt;code&gt;C&lt;/code&gt; (100) 的左边，来表示 40 和 90。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; 可以放在 &lt;code&gt;D&lt;/code&gt; (500) 和 &lt;code&gt;M&lt;/code&gt; (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;III&amp;quot;
输出: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;IV&amp;quot;
输出: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;IX&amp;quot;
输出: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;LVIII&amp;quot;
输出: 58
解释: L = 50, V= 5, III = 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 5:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;MCMXCIV&amp;quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;题解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int romanToInt(string s) {
        int val = 0;
        map&amp;lt;char, int&amp;gt; mp;
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;I&#39;, 1));
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;V&#39;, 5));
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;X&#39;, 10));
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;L&#39;, 50));
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;C&#39;, 100));
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;D&#39;, 500));
        mp.insert(map&amp;lt;char, int&amp;gt;::value_type(&#39;M&#39;, 1000));
        for (int i = 0; i &amp;lt; s.length(); ++i)
        {
            if (mp[s[i]] &amp;gt;= mp[s[i + 1]])
            {
                val += mp[s[i]];
            }
            else
            {
                val += mp[s[i + 1]] - mp[s[i]];
                ++i;
            }
        }
        return val;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后学会更好地在更新。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>7.整数反转</title>
      <link>https://Cdreamfly.github.io/post/7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      
        <description>&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321
 示例 2:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: -123
输出: -321
示例 3:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: 120
输出: 21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^,  2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题解:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    int reverse(int x) {
        if(x / 10 == 0)return x;
        long y = 0;
        while(x)
        {
            y *= 10;
            if(y &amp;gt; INT_MAX || y &amp;lt; INT_MIN)
            {
                return 0;
            }
            y += x % 10;
            x /=  10;
        }
        return y;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后学会更好的在更新。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>9.回文数</title>
      <link>https://Cdreamfly.github.io/post/9.-%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/9.-%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      
        <description>&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: 121
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你能不将整数转为字符串来解决这个问题吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题解:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    bool isPalindrome(int x) {
        if (x &amp;lt; 0)return false;
        if (x &amp;lt; 10)return true;
        if ((x % 10) == 0)return false;

        int res = 0;
        while (x &amp;gt; res) {
            res = 10 * res + (x % 10);
            x = x / 10;
        }
        return x==res||x==res/10;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后学会更好地在更新。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>二叉树（链表表示）</title>
      <link>https://Cdreamfly.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;Node.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once

class Node
{
public:
	Node();
	Node* SearchNode(int indexnode);
	void DeleteNode();
	void PreorderTraversal();
	void InorderTraversal();
	void PostorderTraversal();
	int index;
	int data;
	Node* pLChild;
	Node* pRChild;
	Node* pParent;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Node.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;Node.h&amp;quot;
#include&amp;lt;iostream&amp;gt;
using namespace std;
Node::Node()
{
	index = 0;
	data = 0;
	pLChild = nullptr;
	pRChild = nullptr;
	pParent = nullptr;
}

Node* Node::SearchNode(int nodeindex)
{
	Node* temp = nullptr;
	if (this-&amp;gt;index == nodeindex)return this;
	if (this-&amp;gt;pLChild != nullptr)
	{
		if (this-&amp;gt;pLChild-&amp;gt;index == nodeindex)
		{
			return this-&amp;gt;pLChild;
		}
		else
		{
			temp = this-&amp;gt;pLChild-&amp;gt;SearchNode(nodeindex);
			if (temp != nullptr)return temp;
		}
			
	}
	if (this-&amp;gt;pRChild != nullptr)
	{
		if (this-&amp;gt;pRChild-&amp;gt;index == nodeindex)
		{
			return this-&amp;gt;pRChild;
		}
		else
		{
			temp = this-&amp;gt;pRChild-&amp;gt;SearchNode(nodeindex);
			if (temp != nullptr)return temp;
		}
	}
	return nullptr;
}

void Node::DeleteNode()
{
	if (this-&amp;gt;pLChild != nullptr)
	{
		this-&amp;gt;pLChild-&amp;gt;DeleteNode();
	}
	if (this-&amp;gt;pRChild != nullptr)
	{
		this-&amp;gt;pRChild-&amp;gt;DeleteNode();
	}
	if (this-&amp;gt;pParent != nullptr)
	{
		if (this-&amp;gt;pParent-&amp;gt;pLChild == this)
		{
			this-&amp;gt;pParent-&amp;gt;pLChild = nullptr;
		}
		if (this-&amp;gt;pParent-&amp;gt;pRChild == this)
		{
			this-&amp;gt;pParent-&amp;gt;pRChild = nullptr;
		}
	}
	delete this;
}

void Node::PreorderTraversal()
{
	cout &amp;lt;&amp;lt; this-&amp;gt;index &amp;lt;&amp;lt; &amp;quot;	&amp;quot; &amp;lt;&amp;lt; this-&amp;gt;data &amp;lt;&amp;lt; endl;
	if(this-&amp;gt;pLChild != nullptr)
	{
		this-&amp;gt;pLChild-&amp;gt;PreorderTraversal();
	}
	if (this-&amp;gt;pRChild != nullptr)
	{
		this-&amp;gt;pRChild-&amp;gt;PreorderTraversal();
	}
}

void Node::InorderTraversal()
{
	if (this-&amp;gt;pLChild != nullptr)
	{
		this-&amp;gt;pLChild-&amp;gt;InorderTraversal();
	}
	cout &amp;lt;&amp;lt; this-&amp;gt;index &amp;lt;&amp;lt; &amp;quot;	&amp;quot; &amp;lt;&amp;lt; this-&amp;gt;data &amp;lt;&amp;lt; endl;
	if (this-&amp;gt;pRChild != nullptr)
	{
		this-&amp;gt;pRChild-&amp;gt;InorderTraversal();
	}
}

void Node::PostorderTraversal()
{
	if (this-&amp;gt;pLChild != nullptr)
	{
		this-&amp;gt;pLChild-&amp;gt;PostorderTraversal();
	}
	if (this-&amp;gt;pRChild != nullptr)
	{
		this-&amp;gt;pRChild-&amp;gt;PostorderTraversal();
	}
	cout &amp;lt;&amp;lt; this-&amp;gt;index &amp;lt;&amp;lt; &amp;quot;	&amp;quot; &amp;lt;&amp;lt; this-&amp;gt;data &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tree.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once
#include&amp;quot;Node.h&amp;quot;

class Tree
{
public:
	Tree();
	~Tree();
	Node* SearchNode(int indexnode);
	bool AddNode(int nodeindex, int direction, Node* pNode);
	bool DeleteNode(int nodeindex, Node* pNode);
	void PreorderTraversal();
	void InorderTraversal();
	void PostorderTraversal();
private:
	Node* m_pRoot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tree.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;Tree.h&amp;quot;

Tree::Tree()
{
	m_pRoot = new Node();
}

Tree::~Tree()
{
	m_pRoot-&amp;gt;DeleteNode();
}

Node* Tree::SearchNode(int nodeindex)
{
	return m_pRoot-&amp;gt;SearchNode(nodeindex);
}

bool Tree::AddNode(int nodeindex, int direction, Node* pNode)
{
	Node* temp = SearchNode(nodeindex);
	if (temp == nullptr)return false;
	Node* node = new Node();
	if (node == nullptr)return false;
	node-&amp;gt;index = pNode-&amp;gt;index;
	node-&amp;gt;data = pNode-&amp;gt;data;
	node-&amp;gt;pParent = temp;
	if (direction == 0)
	{
		temp-&amp;gt;pLChild = node;
	}
	if (direction == 1)
	{
		temp-&amp;gt;pRChild = node;
	}
	return true;
}

bool Tree::DeleteNode(int nodeindex, Node* pNode)
{
	Node* temp = SearchNode(nodeindex);
	if (temp == nullptr)return false;

	if (pNode != nullptr)
	{
		pNode-&amp;gt;index = temp-&amp;gt;index;
		pNode-&amp;gt;data = temp-&amp;gt;data;
	}
	temp-&amp;gt;DeleteNode();
	return true;
}

void Tree::PreorderTraversal()
{
	m_pRoot-&amp;gt;PreorderTraversal();
}

void Tree::InorderTraversal()
{
	m_pRoot-&amp;gt;InorderTraversal();
}

void Tree::PostorderTraversal()
{
	m_pRoot-&amp;gt;PostorderTraversal();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;源.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;quot;Tree.h&amp;quot;
using namespace std;

/*
		(0)

	5(1)	8(2)

2(3)  6(4)  9(5)  7(6)

*/

int main()
{
	Node* node1 = new Node();
	node1-&amp;gt;index = 1;
	node1-&amp;gt;data = 5;

	Node* node2 = new Node();
	node2-&amp;gt;index = 2;
	node2-&amp;gt;data = 8;

	Node* node3 = new Node();
	node3-&amp;gt;index = 3;
	node3-&amp;gt;data = 2;

	Node* node4 = new Node();
	node4-&amp;gt;index = 4;
	node4-&amp;gt;data = 6;

	Node* node5 = new Node();
	node5-&amp;gt;index = 5;
	node5-&amp;gt;data = 9;

	Node* node6 = new Node();
	node6-&amp;gt;index = 6;
	node6-&amp;gt;data = 7;

	Tree* tree = new Tree();
	tree-&amp;gt;AddNode(0, 0, node1);
	tree-&amp;gt;AddNode(0, 1, node2);
	tree-&amp;gt;AddNode(1, 0, node3);
	tree-&amp;gt;AddNode(1, 1, node4);
	tree-&amp;gt;AddNode(2, 0, node5);
	tree-&amp;gt;AddNode(2, 1, node6);

	cout &amp;lt;&amp;lt; &amp;quot;前序遍历结果为：&amp;quot; &amp;lt;&amp;lt; endl;
	tree-&amp;gt;PreorderTraversal();

	cout &amp;lt;&amp;lt; &amp;quot;中序遍历结果为：&amp;quot; &amp;lt;&amp;lt; endl;
	tree-&amp;gt;InorderTraversal();

	cout &amp;lt;&amp;lt; &amp;quot;后序遍历结果为：&amp;quot; &amp;lt;&amp;lt; endl;
	tree-&amp;gt;PostorderTraversal();

	tree-&amp;gt;DeleteNode(2, nullptr);

	cout &amp;lt;&amp;lt; &amp;quot;前序遍历结果为：&amp;quot; &amp;lt;&amp;lt; endl;
	tree-&amp;gt;PreorderTraversal();

	delete tree;
	tree = nullptr;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>数据结构之图</title>
      <link>https://Cdreamfly.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/</guid>
      
        <description>

&lt;h2 id=&#34;1-图的定义&#34;&gt;1. 图的定义&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;图（graph）&lt;/strong&gt; 是由一些&lt;strong&gt;点（vertex）&lt;/strong&gt; 和这些点之间的连&lt;strong&gt;线（edge）&lt;/strong&gt; 所组成的；其中，点通常称为&lt;strong&gt;顶点（vertex）&lt;/strong&gt;，而点到点之间的连线通常称之为&lt;strong&gt;边&lt;/strong&gt;或者&lt;strong&gt;弧（edge）&lt;/strong&gt;。通常记为G=（V,E）；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要注意的是：线性表可以是空表，树可以是空树，图不可以是空图，图可以没有边，但是至少要有一个顶点。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-图的组成&#34;&gt;2. 图的组成&lt;/h2&gt;

&lt;p&gt;图由两种类型的元素组成，&lt;strong&gt;顶点&lt;/strong&gt;和&lt;strong&gt;边&lt;/strong&gt;，有时候，有向图的边也称为&lt;strong&gt;弧&lt;/strong&gt;。
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221114746395.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
- &lt;strong&gt;顶点&lt;/strong&gt;代表&lt;strong&gt;对象&lt;/strong&gt;，边则建立起对象之间的&lt;strong&gt;关系&lt;/strong&gt;或&lt;strong&gt;关联&lt;/strong&gt;。
 - &lt;strong&gt;入度&lt;/strong&gt;就是进入该顶点边的数目，&lt;strong&gt;出度&lt;/strong&gt;就是离开这个顶点边的数目，有向图的&lt;strong&gt;度&lt;/strong&gt;就是入度加出度。
 - &lt;strong&gt;边&lt;/strong&gt;是顶点之间的&lt;strong&gt;逻辑关系&lt;/strong&gt;表示，边集可以是空的&lt;/p&gt;

&lt;h2 id=&#34;3-图的分类&#34;&gt;3. 图的分类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;和&lt;strong&gt;无向图&lt;/strong&gt;。&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221111259440.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有向图&lt;/strong&gt;中，边是由两个顶点组成的有序对，具有特定的方向。形象地说，有向图可以由顶点和带方向的箭头所组成的圈绘制出来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;中，边是没有方向的，因此，无向图的边就直接用线段来代替箭头表示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全图&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221113500823.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完全图&lt;/strong&gt;如果任意两个顶点之间都存在边叫&lt;strong&gt;完全图&lt;/strong&gt;，而有向的边叫&lt;strong&gt;有向完全图&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当一个图接近完全图时，则称它为&lt;strong&gt;稠密图&lt;/strong&gt;（Dense Graph），而当一个图含有较少的边时，则称它为&lt;strong&gt;稀疏图&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;连通图&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221113845851.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无向图&lt;/strong&gt;中，两顶点有路径存在，就称为连通的。若图中任意两顶点都连通，同此图为&lt;strong&gt;连通图&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;无权图&lt;/strong&gt;和&lt;strong&gt;带权图&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221115359481.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对图中的&lt;strong&gt;边&lt;/strong&gt;赋予具有一定意义的数值(路程、费用等等)的图称为&lt;strong&gt;带权图&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-图的存储结构&#34;&gt;4. 图的存储结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221115930425.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;邻接矩阵&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221120021736.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;邻接矩阵&lt;/strong&gt;用两个数组保存数据。一个一维数组存储图中&lt;strong&gt;顶点信息&lt;/strong&gt;，一个二维数组（邻接矩阵）存储图中&lt;strong&gt;边的信息&lt;/strong&gt;。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;顶点v1 和顶点v3 之间存在一条边， 则称顶点v1 和3 互为&lt;strong&gt;邻接点&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;有向图邻接矩阵&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221121019724.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;无向图邻接矩阵&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221121033528.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;0 表示这两个顶点之间没有边，1 表示有边&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对应行非0元素的个数是&lt;strong&gt;出度&lt;/strong&gt;；对应列非0元素的个数是&lt;strong&gt;入度&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 可以快速判断两个顶点之间是否存在边，可以快速添加边或者删除边。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 由于存在n个顶点的图需要n*n个数组元素进行存储，当图为&lt;strong&gt;稀疏图&lt;/strong&gt;时，使用邻接矩阵存储方法将会出现大量0元素，这会造成极大的空间浪费。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Cdreamfly/article/details/104423508&#34;&gt;实现代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-深度优先搜索&#34;&gt;5. 深度优先搜索&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221132056540.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
 - &lt;strong&gt;深度优先搜索&lt;/strong&gt;在搜索过程中每当访问到某一个顶点后，需要&lt;strong&gt;递归地访问此顶点的所有未访问过的相邻顶点&lt;/strong&gt;。因而，这种搜索将尽可能深地持续探索，直到无法继续为止。&lt;/p&gt;

&lt;h2 id=&#34;6-广度优先搜索&#34;&gt;6. 广度优先搜索&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221132104705.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
 - &lt;strong&gt;广度优先搜索&lt;/strong&gt;在进一步探索图中的顶点之前，先访问当前顶点的所有邻接顶点。&lt;/p&gt;

&lt;h2 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kruskal 算法&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221133239218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;

&lt;ul&gt;
&lt;li&gt;此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prim 算法&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200221133256206.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; /&gt;

&lt;ul&gt;
&lt;li&gt;此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点A开始，逐渐长大覆盖整个连通网的所有顶点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>数据结构之树</title>
      <link>https://Cdreamfly.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91/</guid>
      
        <description>

&lt;h3 id=&#34;本质问题&#34;&gt;本质问题&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;不是线性表，是一种描述非线性&lt;strong&gt;层次关系&lt;/strong&gt;的数据结构。描述的是一对多的数据结构。&lt;/p&gt;

&lt;h4 id=&#34;1-树的定义&#34;&gt;1. 树的定义&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;树(Tree)的基本概念
树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-基本特征&#34;&gt;2. 基本特征&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;有且仅有一个结点没有直接前驱，那就是根节点。&lt;/li&gt;
&lt;li&gt;除了根结点外，其他结点有且仅有一个直接前驱。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个结点可以有任意后继结点。&lt;/p&gt;

&lt;h4 id=&#34;3-基本概念&#34;&gt;3. 基本概念&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;兄弟结点——拥有同一个父结点的结点。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;孩子、双亲——结点的子树的根称为该节点的孩子，相应地，该节点称为孩子的双亲。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结点的度——一个结点所包含子树的数量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;树的度——该树所有结点中最大的度。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;叶子结点——树中度为零的结点，也叫终端结点。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结点的层数——从根结点开始算，根结点是第一层，依次往下。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;树的深度——树中结点的最大层数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有序树——树中的各结点的&lt;strong&gt;子树（兄弟结点）&lt;/strong&gt; &lt;em&gt;从左到右按一定次序去排列的树。&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;森林——m(m&amp;gt;=0)棵&lt;strong&gt;互不相交&lt;/strong&gt;的树的集合。&lt;/p&gt;

&lt;h4 id=&#34;4-树的种类&#34;&gt;4. 树的种类&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二叉树：每个节点最多含有两个子树的树称为二叉树；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完全二叉树&lt;/li&gt;
&lt;li&gt;满二叉树&lt;/li&gt;
&lt;li&gt;斜树&lt;/li&gt;
&lt;li&gt;平衡二叉树&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；&lt;/p&gt;

&lt;h4 id=&#34;5-二叉树&#34;&gt;5. 二叉树&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;特点:&lt;/li&gt;
&lt;li&gt;每个结点最多只有两个子结点，可以没有或者只有一个。&lt;/li&gt;
&lt;li&gt;左子树和右子树是有顺序的，次序不能任意颠倒。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;斜树：所有节点都只有左子树的二叉树叫做左斜树，所有节点都只有右节点的二叉树叫做右斜树，这两者统称为斜树。&lt;/li&gt;
&lt;li&gt;满二叉树：除了最下面一层的叶子结点外，其他结点都有两个子结点；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完全二叉树：除了最下面一层的叶子结点外，其他各层结点数达到最大个数，而且最后一层叶子结点按照从左到右的顺序连续存在，只缺最后一层若干结点；&lt;/p&gt;

&lt;h4 id=&#34;6-二叉树的性质&#34;&gt;6. 二叉树的性质&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;性质1：在二叉树的第i层上至多有2^i^-1个节点(i &amp;gt;= 1)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;性质2：深度为k的二叉树至多有2^k^-1个节点(k &amp;gt;=1)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;性质3：对于任意一棵二叉树T而言，其叶子节点数目为N~0~,度为2的节点数目为N~2~，则有N~0~ = N~2~ + 1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;性质4：具有n个节点的完全二叉树的深度(log~2~n)+1(括号内的值取下限)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;性质5：一棵完全二叉树，其深度为，节点编号按层编号，每层从左至右编号，则对任意节点i(1&amp;lt;= i &amp;lt;= n)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（1）        如果i = 1，则该点为根节点，无双亲，否则其双亲为(i/2)(括号内的值取下限)；&lt;/li&gt;
&lt;li&gt;（2）        如果2i&amp;gt;0，则该点无左孩子（节点为叶子节点），否则其左孩子为2i;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;（3）        如果2i+1，则该点无右孩子，否则其左孩子为2i+1;&lt;/p&gt;

&lt;h4 id=&#34;7-存储方式&#34;&gt;7. 存储方式&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二叉树的顺序存储结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;二叉树的顺序存储结构用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要体现出结点之间的逻辑关系。&lt;/li&gt;
&lt;li&gt;就是从根结点开始一层层地按顺序存储在数组里，但是只适用于完全二叉树，因为非完全二叉树的话，可能会浪费大量的存储空间。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/Cdreamfly/article/details/104319492&#34;&gt;代码实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二叉链表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因为二叉树最多有两个孩子，所以二叉链表拥有一个数据域和两个指针域。&lt;/li&gt;
&lt;li&gt;如果有需要还可以再增加一个指向其双亲的指针域，那就称为三叉链表。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Cdreamfly/article/details/104364705&#34;&gt;代码实现&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;8-二叉树的遍历&#34;&gt;8. 二叉树的遍历&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;先序：先访问根结点，后是左子树，到右子树；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中序：先左子树，后根结点，最后是右子树；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;后序：先左子树，后右子树，最后根结点；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;层序：从上到下，从左到右依次遍历每一层中的每一个节点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>汇编语言-绪论</title>
      <link>https://Cdreamfly.github.io/post/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Wed, 01 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%BB%AA%E8%AE%BA/</guid>
      
        <description>

&lt;h2 id=&#34;1-机器语言与机器指令&#34;&gt;1. 机器语言与机器指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;机器语言&lt;/strong&gt;是机器指令的集合。
&lt;strong&gt;机器指令&lt;/strong&gt;是一台机器可以正确执行的命令。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;机器指令&lt;/strong&gt;有一串二进制数表示，如010101&lt;/p&gt;

&lt;h2 id=&#34;汇编语言与汇编指令&#34;&gt;汇编语言与汇编指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;汇编语言&lt;/strong&gt;的主题是汇编指令。
&lt;strong&gt;汇编指令&lt;/strong&gt;和机器指令的差别在于指令的表示方法上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;汇编指令&lt;/strong&gt;是机器指令便于记忆的书写格式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;汇编指令&lt;/strong&gt;是机器指令的助记符。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;运行流程：&lt;/strong&gt; &lt;strong&gt;汇编指令 &amp;ndash;&amp;gt; 编译器 &amp;ndash;&amp;gt; 机器码 &amp;ndash;&amp;gt; 计算机&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-指令和数据的表示&#34;&gt;2.指令和数据的表示&lt;/h2&gt;

&lt;p&gt;计算机中的数据和指令，存储在内存或者磁盘上。
数据和指令，都是二进制信息。
&lt;strong&gt;问题：&lt;/strong&gt; 二进制信息1000100111011000是数据，还是指令？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1000100111011000&amp;ndash;&amp;gt;89D8H(数据)&lt;/li&gt;
&lt;li&gt;1000100111011000&amp;ndash;&amp;gt;MOV AX,BX(程序)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;如何表示？
- 1000100111011000B（&lt;strong&gt;二进制&lt;/strong&gt;）
- 89D8H（&lt;strong&gt;十六进制&lt;/strong&gt;）
- 104730O（&lt;strong&gt;八进制&lt;/strong&gt;）
- 35288D（&lt;strong&gt;十进制&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据量：&lt;/strong&gt; &lt;strong&gt;B, KB, MB, GB, TB。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-计算机中的存储单元&#34;&gt;3. 计算机中的存储单元&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;存储器被划分位若干个存储单元，每个存储单元从0开始顺序编写；&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-计算机中的总线&#34;&gt;4. 计算机中的总线&lt;/h2&gt;

&lt;p&gt;在计算机中专门有连接CPU和其他芯片的导线，通常称为&lt;strong&gt;总线&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;物理上：&lt;/strong&gt;
- 一根根导线的集合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑上划分位：&lt;/strong&gt;
- 地址总线：
  - CPU是通过&lt;strong&gt;地址总线&lt;/strong&gt;来指定存储单元的。
  - 地址总线的宽度，决定了可寻址的存储单元大小。
  - N根地址总线（宽度位N），对应&lt;strong&gt;寻址空间&lt;/strong&gt;为&lt;strong&gt;2^N^&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据总线&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。&lt;/li&gt;
&lt;li&gt;数据总线的宽度决定了CPU和外界的数据传送速度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;控制总线&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU通过&lt;strong&gt;控制总线&lt;/strong&gt;对外部期间进行控制。&lt;/li&gt;
&lt;li&gt;控制总线是一些不同控制线的集合。&lt;/li&gt;
&lt;li&gt;控制总线宽度决定了CPU对外部器件的控制能力。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-cpu对存储器的读写&#34;&gt;5. CPU对存储器的读写&lt;/h2&gt;

&lt;p&gt;CPU要想进行数据的读写，必须和外部期间进行三类信息的交互：
1. 存储单元的地址（&lt;strong&gt;地址信息&lt;/strong&gt;）
2. 器件的选择，读或写命令（&lt;strong&gt;控制信息&lt;/strong&gt;）
3. 读或写的数据（&lt;strong&gt;数据信息&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt; CPU想要读内存中地址号位3的数据，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CPU先发出地址信息为3从，&lt;strong&gt;地址线&lt;/strong&gt;发出，&lt;/li&gt;
&lt;li&gt;在发出控制信息为读，从&lt;strong&gt;控制线&lt;/strong&gt;发出，&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后内存中的数据，从&lt;strong&gt;数据线&lt;/strong&gt;传过来了放在寄存器中。&lt;/p&gt;

&lt;h2 id=&#34;6-内存地址空间&#34;&gt;6. 内存地址空间&lt;/h2&gt;

&lt;p&gt;什么是&lt;strong&gt;内存地址空间&lt;/strong&gt;？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CPU的地址总线宽度为N，&lt;strong&gt;寻址空间&lt;/strong&gt;为2^N^B&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;8086CPU的地址总线为20，那么可以寻址1MB个内存单元，其&lt;strong&gt;内存地址空间&lt;/strong&gt;为1MB.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从CPU角度看&lt;strong&gt;地址空间分配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RAM:&lt;/strong&gt; 主板上的RAM 扩展槽上的RAM（例显卡）
&lt;strong&gt;ROM:&lt;/strong&gt; 系统BIOS 接口卡上的BIOS&lt;/p&gt;

&lt;p&gt;将各类存储器看作一个&lt;strong&gt;逻辑存储器&lt;/strong&gt; &amp;mdash; &lt;strong&gt;统一编址&lt;/strong&gt;
- 所有的物理从存储器被看作一个有若干存储单元组成的&lt;strong&gt;逻辑存储器&lt;/strong&gt;；
- 每个物理存储器在这个&lt;strong&gt;逻辑存储器&lt;/strong&gt;中占有一个地址段，即一段&lt;strong&gt;地址空间&lt;/strong&gt;；&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://Cdreamfly.github.io/post/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      
        <description>&lt;p&gt;给定一个只包括&lt;code&gt;&amp;rsquo;(&amp;rsquo;&lt;/code&gt;，&lt;code&gt;&amp;rsquo;)&amp;rsquo;&lt;/code&gt;，&lt;code&gt;&amp;rsquo;{&amp;rsquo;&lt;/code&gt;，&lt;code&gt;&amp;rsquo;}&amp;rsquo;&lt;/code&gt;，&lt;code&gt;&amp;lsquo;[&amp;rsquo;&lt;/code&gt;，&lt;code&gt;&amp;rsquo;]&amp;rsquo;&lt;/code&gt; 的字符串，判断字符串是否有效。&lt;/p&gt;

&lt;p&gt;有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。&lt;/p&gt;

&lt;p&gt;注意空字符串可被认为是有效字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;()&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;()[]{}&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;(]&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;([)]&amp;quot;
输出: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例 5:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入: &amp;quot;{[]}&amp;quot;
输出: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;题解:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    bool isValid(string s) {
        stack&amp;lt;char&amp;gt;st;
        int len = s.size();
        if (len == 0)return true;
        if (len % 2 != 0)return false;
        if (s[0] == &#39;)&#39; || s[0] == &#39;}&#39; || s[0] == &#39;]&#39;)return false;
        for (int i = 0; i &amp;lt; len; ++i)
        {
            if (st.empty())
            {
                st.push(s[i]);
                continue;
            }
            if (st.top() == &#39;(&#39; &amp;amp;&amp;amp; s[i] == &#39;)&#39;)
            {
                st.pop();
                continue;
            }
            if (st.top() == &#39;{&#39; &amp;amp;&amp;amp; s[i] == &#39;}&#39;)
            {
                st.pop();
                continue;
            }
            if (st.top() == &#39;[&#39; &amp;amp;&amp;amp; s[i] == &#39;]&#39;)
            {
                st.pop();
                continue;
            }
            st.push(s[i]);
        }
        return st.empty();
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以后学会更好的在更新。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://Cdreamfly.github.io/post/cmd-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/cmd-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid>
      
        <description>

&lt;h1 id=&#34;cmd-输入输出&#34;&gt;cmd 输入输出&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;首先在编写如&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define _CRT_SECURE_NO_WARNINGS
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;

void main()
{
	int a = 0;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);
	printf(&amp;quot;%d\n&amp;quot;,a);
	system(&amp;quot;pause&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 cmd.exe, 打开 cmd 并进入到 cmd.exe 的目录&lt;/p&gt;

&lt;p&gt;我们可以再新建以个1.txt并在里面输入 &lt;code&gt;123 &lt;/cdoe&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在cmd窗口中输入:&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200214131340470.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; : 是将 1.txt 中输入的数据输出到 cmd.exe 正如代码中的 scanf() 接受&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; : 是将 cmd.exe 输入的数据输入到 2.txt 中正如 printf()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;还可以将cmd内容输出到文本例如:&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200214131124634.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;就会生成 3.txt:&lt;/strong&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200214131050784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NkcmVhbWZseQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;3.txt&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://Cdreamfly.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;.h 文件：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once

class Tree
{
public:
	Tree(int size, int* pRoot);
	~Tree();
	int* SearchNode(int nodeIndex);  //查找
	bool AddNode(int nodeIndex, int direction, int* pNode);//添加
	bool DeleteNode(int nodeIndex, int* pNode);//删除
	void TreeTraverse();//遍历
private:
	int* m_pTree;  
	int m_Size;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;.cpp 文件:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include &amp;quot;Tree.h&amp;quot;
using namespace std;

Tree::Tree(int size, int* pRoot)
{
	m_Size = size;
	m_pTree = new int[size];

	for (int i = 0; i &amp;lt; size; ++i)
	{
		m_pTree[i] = 0;
	}

	m_pTree[0] = *pRoot;
}

Tree::~Tree()
{
	delete[] m_pTree;
	m_pTree = nullptr;
}

int* Tree::SearchNode(int nodeIndex)
{
	if (nodeIndex &amp;lt; 0 || nodeIndex &amp;gt;= m_Size)return nullptr;
	if (m_pTree[nodeIndex] == 0)return nullptr;

	return &amp;amp;m_pTree[nodeIndex];
}

bool Tree::AddNode(int nodeIndex, int direction, int* pNode)
{
	if (nodeIndex &amp;lt; 0 || nodeIndex &amp;gt;= m_Size)return false;  //判断父节点索引是否正确
	if (m_pTree[nodeIndex] == 0)return false;  //判断父节点是否为空

	if (direction == 0) //左
	{
		if (nodeIndex * 2 + 1 &amp;gt;= m_Size)return false; //判断左孩子索引是否正确
		if (m_pTree[nodeIndex * 2 + 1] != 0)return false; //左孩子不为0说明已经有数据

		m_pTree[nodeIndex * 2 + 1] = *pNode;
	}
	if (direction == 1)//右
	{
		if (nodeIndex * 2 + 2 &amp;gt;= m_Size)return false;
		if (m_pTree[nodeIndex * 2 + 2] != 0)return false;

		m_pTree[nodeIndex * 2 + 2] = *pNode;
	}
	return true;
}

bool Tree::DeleteNode(int nodeIndex, int* pNode)
{
	if (nodeIndex &amp;lt; 0 || nodeIndex &amp;gt;= m_Size)return false;
	if (m_pTree[nodeIndex] == 0)return false;

	*pNode = m_pTree[nodeIndex];
	m_pTree[nodeIndex] = 0;

	return true;
}

void Tree::TreeTraverse()
{
	for (int i = 0; i &amp;lt; m_Size; ++i)
	{
		cout &amp;lt;&amp;lt; m_pTree[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;quot;Tree.h&amp;quot;
using namespace std;

int main()
{
	int root = 3;
	Tree* pt = new Tree(10,&amp;amp;root);
	int node1 = 5;
	int node2 = 8;
	int node3 = 2;
	int node4 = 6;
	int node5 = 9;
	int node6 = 7;

	pt-&amp;gt;AddNode(0, 0, &amp;amp;node1);
	pt-&amp;gt;AddNode(0, 1, &amp;amp;node2);

	pt-&amp;gt;AddNode(1, 0, &amp;amp;node3);
	pt-&amp;gt;AddNode(1, 1, &amp;amp;node4);

	pt-&amp;gt;AddNode(2, 0, &amp;amp;node5);
	pt-&amp;gt;AddNode(2, 1, &amp;amp;node6);
	
	int node = 0;
	pt-&amp;gt;DeleteNode(6, &amp;amp;node);
	cout &amp;lt;&amp;lt; node &amp;lt;&amp;lt; endl;

	pt-&amp;gt;TreeTraverse();
	cout &amp;lt;&amp;lt; endl;

	int *p = pt-&amp;gt;SearchNode(2);
	cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;

	delete pt;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://Cdreamfly.github.io/post/%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Cdreamfly.github.io/post/%E5%9B%BE%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;Node.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once

class Node
{
public:
	Node(char data = 0);
	char m_cData;
	bool m_bIsVisited;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Node.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;Node.h&amp;quot;

Node::Node(char data)
{
	m_cData = data;
	m_bIsVisited = false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;CMap.h&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once
#include&amp;quot;Node.h&amp;quot;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
using namespace std;
class CMap
{
public:
	CMap(int capacity);
	~CMap();
	bool addNode(Node* pNode);//添加顶点
	void resetNode();//重置顶底
	bool setValueToMatrixForDirectedGraph(int row, int col, int val = 1);//为有向图设置邻接矩阵
	bool setValueToMatrixForUndirectedGraph(int row, int col, int val = 1);//为无向图设置邻接矩阵
	void printMatrix();//打印邻接矩阵
	void depthFirstTraverse(int nodeIndex);  //深度优先遍历
	void breadthFirstTraverse(int nodeIndex);//广度优先遍历
private:
	bool getValueFromMatrix(int row, int col, int&amp;amp; val);//广度优先遍历实现函数
	void breadthFirstTraverseImpl(vector&amp;lt;int&amp;gt;preVec);//
private:
	int m_iCapacity; //最多顶点数
	int m_iNodeCount;//已经添加的顶点数
	Node* m_pNodeArray;//用来存放顶点的数组
	int* m_pMatrix;//用来存放顶点的邻接矩阵
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;CMap.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;CMap.h&amp;quot;
CMap::CMap(int capacity)
{
	m_iCapacity = capacity;
	m_iNodeCount = 0;
	m_pNodeArray = new Node[m_iCapacity];
	m_pMatrix = new int[m_iCapacity * m_iCapacity];
	for (int i = 0; i &amp;lt; m_iCapacity * m_iCapacity; i++)
	{
		m_pMatrix[i] = 0;
	}
}

CMap::~CMap()
{
	delete[] m_pNodeArray;
	delete[] m_pMatrix;
}

bool CMap::addNode(Node* pNode)
{
	if (pNode == NULL)
	{
		return false;
	}
	m_pNodeArray[m_iNodeCount].m_cData = pNode-&amp;gt;m_cData;
	m_iNodeCount++;
	return true;
}

void CMap::resetNode()
{
	for (int i = 0; i &amp;lt; m_iNodeCount; i++)
	{
		m_pNodeArray[i].m_bIsVisited = false;
	}
}

bool CMap::setValueToMatrixForDirectedGraph(int row, int col, int val)
{
	if (row &amp;lt; 0 || row &amp;gt;= m_iCapacity)
	{
		return false;
	}
	if (col &amp;lt; 0 || col &amp;gt;= m_iCapacity)
	{
		return false;
	}
	m_pMatrix[row * m_iCapacity + col] = val;
	return true;
}

bool CMap::setValueToMatrixForUndirectedGraph(int row, int col, int val)
{
	if (row &amp;lt; 0 || row &amp;gt;= m_iCapacity)
	{
		return false;
	}
	if (col &amp;lt; 0 || col &amp;gt;= m_iCapacity)
	{
		return false;
	}
	m_pMatrix[row * m_iCapacity + col] = val;
	m_pMatrix[col * m_iCapacity + row] = val;
	return true;
}

void CMap::printMatrix()
{
	for (int i = 0; i &amp;lt; m_iCapacity; i++)
	{
		for (int j = 0; j &amp;lt; m_iCapacity; j++)
		{
			cout &amp;lt;&amp;lt; m_pMatrix[i * m_iCapacity + j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
		}
		cout &amp;lt;&amp;lt; endl;
	}
}

void CMap::depthFirstTraverse(int nodeIndex)
{
	int value = 0;
	cout &amp;lt;&amp;lt; m_pNodeArray[nodeIndex].m_cData &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
	m_pNodeArray[nodeIndex].m_bIsVisited = true;
	for (int i = 0; i &amp;lt; m_iCapacity; i++)
	{
		getValueFromMatrix(nodeIndex, i, value);
		if (value == 1)
		{
			if (m_pNodeArray[i].m_bIsVisited)
			{
				continue;
			}
			else
			{
				depthFirstTraverse(i);
			}
		}
		else
		{
			continue;
		}
	}
}

bool CMap::getValueFromMatrix(int row, int col, int&amp;amp; val)
{
	if (row &amp;lt; 0 || row &amp;gt;= m_iCapacity)
	{
		return false;
	}
	if (col &amp;lt; 0 || col &amp;gt;= m_iCapacity)
	{
		return false;
	}
	val = m_pMatrix[row * m_iCapacity + col];
	return true;
}

void CMap::breadthFirstTraverse(int nodeIndex)
{
	cout &amp;lt;&amp;lt; m_pNodeArray[nodeIndex].m_cData &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
	m_pNodeArray[nodeIndex].m_bIsVisited = true;

	vector&amp;lt;int&amp;gt;curVec;
	curVec.push_back(nodeIndex);
	breadthFirstTraverseImpl(curVec);
}

void CMap::breadthFirstTraverseImpl(vector&amp;lt;int&amp;gt; preVec)
{
	int value = 0;
	vector&amp;lt;int&amp;gt;curVec;
	for (int j = 0; j &amp;lt; (int)preVec.size(); j++)
	{
		for (int i = 0; i &amp;lt; m_iCapacity; i++)
		{
			getValueFromMatrix(preVec[j], i, value);
			if (value != 0)
			{
				if (m_pNodeArray[i].m_bIsVisited)
				{
					continue;
				}
				else
				{
					cout &amp;lt;&amp;lt; m_pNodeArray[i].m_cData &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
					m_pNodeArray[i].m_bIsVisited = true;
					curVec.push_back(i);

				}
			}
		}
	}
	if (curVec.size() == 0)
	{
		return;
	}
	else
	{
		breadthFirstTraverseImpl(curVec);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;源.cpp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;quot;Node.h&amp;quot;
#include&amp;quot;CMap.h&amp;quot;

int main()
{
	CMap* pMap = new CMap(8);
	Node* pNodeA = new Node(&#39;A&#39;);
	Node* pNodeB = new Node(&#39;B&#39;);
	Node* pNodeC = new Node(&#39;C&#39;);
	Node* pNodeD = new Node(&#39;D&#39;);
	Node* pNodeE = new Node(&#39;E&#39;);
	Node* pNodeF = new Node(&#39;F&#39;);
	Node* pNodeG = new Node(&#39;G&#39;);
	Node* pNodeH = new Node(&#39;H&#39;);

	pMap-&amp;gt;addNode(pNodeA);
	pMap-&amp;gt;addNode(pNodeB);
	pMap-&amp;gt;addNode(pNodeC);
	pMap-&amp;gt;addNode(pNodeD);
	pMap-&amp;gt;addNode(pNodeE);
	pMap-&amp;gt;addNode(pNodeF);
	pMap-&amp;gt;addNode(pNodeG);
	pMap-&amp;gt;addNode(pNodeH);

	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(0, 1);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(0, 3);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(1, 2);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(1, 5);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(3, 6);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(3, 7);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(6, 7);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(2, 4);
	pMap-&amp;gt;setValueToMatrixForUndirectedGraph(4, 5);

	pMap-&amp;gt;printMatrix();
	cout &amp;lt;&amp;lt; endl;
	pMap-&amp;gt;depthFirstTraverse(0);
	pMap-&amp;gt;resetNode();
	cout &amp;lt;&amp;lt; endl;
	pMap-&amp;gt;breadthFirstTraverse(0);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
  </channel>
</rss>
